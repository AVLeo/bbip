/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef bbip_TYPES_H
#define bbip_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace bilibili {

class bbip_result;

class InvalidOperation;

typedef struct _bbip_result__isset {
  _bbip_result__isset() : range_start(false), range_end(false), country(false), province(false), city(false), district(false), isp(false), type(false), desc(false), lat(false), lng(false), cidr(false) {}
  bool range_start :1;
  bool range_end :1;
  bool country :1;
  bool province :1;
  bool city :1;
  bool district :1;
  bool isp :1;
  bool type :1;
  bool desc :1;
  bool lat :1;
  bool lng :1;
  bool cidr :1;
} _bbip_result__isset;

class bbip_result {
 public:

  bbip_result(const bbip_result&);
  bbip_result& operator=(const bbip_result&);
  bbip_result() : range_start(0), range_end(0), country(), province(), city(), district(), isp(), type(), desc(), lat(0), lng(0), cidr(0) {
  }

  virtual ~bbip_result() throw();
  int64_t range_start;
  int64_t range_end;
  std::string country;
  std::string province;
  std::string city;
  std::string district;
  std::string isp;
  std::string type;
  std::string desc;
  double lat;
  double lng;
  int16_t cidr;

  _bbip_result__isset __isset;

  void __set_range_start(const int64_t val);

  void __set_range_end(const int64_t val);

  void __set_country(const std::string& val);

  void __set_province(const std::string& val);

  void __set_city(const std::string& val);

  void __set_district(const std::string& val);

  void __set_isp(const std::string& val);

  void __set_type(const std::string& val);

  void __set_desc(const std::string& val);

  void __set_lat(const double val);

  void __set_lng(const double val);

  void __set_cidr(const int16_t val);

  bool operator == (const bbip_result & rhs) const
  {
    if (!(range_start == rhs.range_start))
      return false;
    if (!(range_end == rhs.range_end))
      return false;
    if (!(country == rhs.country))
      return false;
    if (!(province == rhs.province))
      return false;
    if (!(city == rhs.city))
      return false;
    if (!(district == rhs.district))
      return false;
    if (!(isp == rhs.isp))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(desc == rhs.desc))
      return false;
    if (__isset.lat != rhs.__isset.lat)
      return false;
    else if (__isset.lat && !(lat == rhs.lat))
      return false;
    if (__isset.lng != rhs.__isset.lng)
      return false;
    else if (__isset.lng && !(lng == rhs.lng))
      return false;
    if (!(cidr == rhs.cidr))
      return false;
    return true;
  }
  bool operator != (const bbip_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const bbip_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(bbip_result &a, bbip_result &b);

inline std::ostream& operator<<(std::ostream& out, const bbip_result& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidOperation__isset {
  _InvalidOperation__isset() : code(false), msg(false) {}
  bool code :1;
  bool msg :1;
} _InvalidOperation__isset;

class InvalidOperation : public ::apache::thrift::TException {
 public:

  InvalidOperation(const InvalidOperation&);
  InvalidOperation& operator=(const InvalidOperation&);
  InvalidOperation() : code(0), msg() {
  }

  virtual ~InvalidOperation() throw();
  int32_t code;
  std::string msg;

  _InvalidOperation__isset __isset;

  void __set_code(const int32_t val);

  void __set_msg(const std::string& val);

  bool operator == (const InvalidOperation & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const InvalidOperation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidOperation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidOperation &a, InvalidOperation &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidOperation& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
