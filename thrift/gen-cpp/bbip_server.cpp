// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "bbip.h"
#include <unistd.h>
#include <getopt.h>
#include <sys/mman.h>
#include <arpa/inet.h>
#include <sys/resource.h>
#include <string.h>
#include "libbbip.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::bilibili;

typedef struct {
  int contient;
  int area;
  int country;
} bbip_country_zone_t;

typedef struct {
  int province;
  int province_area;
  int isp;
} bbip_province_zone_t;

static double atof_length(char *line, size_t n)
{
    double   value;
    int      dot;
    int      neg = 0;
    int      point = 0;

    if (n == 0) {
        return 0;
    }

    dot = 0;

    for (value = 0; n--; line++) {

        if (*line == '.') {
            if (dot) {
                return 0;
            }

            dot = 1;
            continue;
        }

        if (*line == '-') {
          if (neg) {
            return 0;
          }

          neg = 1;

          value = -value;
          continue;
        }

        if (*line < '0' || *line > '9') {
            return 0;
        }

        value = value * 10 + (*line - '0') * (neg ? -1 : 1);
        point += dot;
    }

    while (point--) {
        value = value / 10;
    }

    return value;
}

class bbipHandler : virtual public bbipIf {
 public:
  bbipHandler() {
    // Your initialization goes here
  }

  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   */
  void ping() {
    // Your implementation goes here
    printf("ping\n");
    sleep(3);
  }

  int32_t count() {
    // Your implementation goes here
    return this->ps->nCount;
  }

  void query(bbip_result& _return, const std::string& string_ip) {
    // Your implementation goes here
    struct in_addr addr;
    unsigned long ip;
    if (!inet_aton(string_ip.c_str(), &addr))
    {
        InvalidOperation io;
        io.code = 1;
        io.msg = "Argument 1 must be a IP. Failed to resolve IP.";
        throw io;
    }
    ip = ntohl(addr.s_addr);

    this->query_long(_return, ip);    
  }

  int16_t GetAreaFlag(const std::string& string_ip) {
    struct in_addr addr;
    unsigned long ip;
    if (!inet_aton(string_ip.c_str(), &addr))
    {
        InvalidOperation io;
        io.code = 1;
        io.msg = "Argument 1 must be a IP. Failed to resolve IP.";
        throw io;
    }
    ip = ntohl(addr.s_addr);

    int arealimit_flag = 0;

    long key = bbip_query(this->ps,ip);
    if (key == 0) {
        return 0;
    } else {
        if (ps->index_ptr[key] == 0)
        {
            this->ps->ptr = BASE_PTR+(this->ps->nCount*2+key-1)*sizeof(int);
            this->ps->index_ptr[key] = htonl(*(int *)(this->ps->mmap+this->ps->ptr));
        }
        this->ps->ptr = this->ps->index_ptr[key]+4;

        unsigned char ilen;
        char *data;

        data=bbip_getstr(ps,&ilen);

        std::string country(data,ilen);

        if (country == "中国") {
            arealimit_flag |= 2;

            data=bbip_getstr(ps,&ilen);
            std::string province(data,ilen);
            if (province == "香港" || province == "澳门" || province == "台湾") {
                arealimit_flag = 1;
            }
        } else if (country == "日本") {
            arealimit_flag |= 4;
        } else if (country == "美国") {
            arealimit_flag |= 8;
        } else if (country == "局域网") {
            arealimit_flag = 0;
        } else {
            arealimit_flag |= 16;
        }
    }
    return arealimit_flag;
  }

  #define GROUP_CONC(a,b,c,d) a ## ## b ## c ## d
  #define FIND_IN_COUNTRY_GROUPS(_contient,_area,rc,_country) { \
    int group_cnt = sizeof(GROUP_CONC(c,_contient,_a,_area)) / sizeof(void *); \
    int i; \
    for (i=0;i<group_cnt;i++) { \
      if (GROUP_CONC(c,_contient,_a,_area)[i] == _country) { \
        rc.contient = _contient; \
        rc.area = _area; \
        rc.country = i+1; \
        return &rc; \
      } \
    } \
  }
  #define FIND_IN_PROVINCE_GROUPS(_area,rc,_province) { \
    int group_cnt = sizeof(GROUP_CONC(c,0,_a,_area)) / sizeof(void *); \
    int i; \
    for (i=0;i<group_cnt;i++) { \
      if (GROUP_CONC(c,0,_a,_area)[i] == _province) { \
        rc.province = i + 1; \
        rc.province_area = _area; \
      } \
    } \
  }
  bbip_country_zone_t *_getCountryData(string country) {
      static bbip_country_zone_t rc = { 0, 0, 0 };

      rc.contient = 0;
      rc.area = 0;
      rc.country = 0;
      // ASIA
      string c1_a1[] = {"中国","日本","韩国","蒙古","朝鲜"};
      string c1_a2[] = {"印度","马尔代夫","不丹","尼泊尔","孟加拉","巴基斯坦","斯里兰卡"};
      string c1_a3[] = {"阿富汗","伊朗","伊拉克","科威特","格鲁吉亚","阿塞拜疆","土耳其","卡塔尔","巴林","阿联酋","沙特阿拉伯","也门","阿曼","叙利亚","黎巴嫩","约旦","以色列","塞浦路斯","亚美尼亚"};
      string c1_a4[] = {"巴勒斯坦","乌兹别克斯坦","塔吉克斯坦","吉尔吉斯斯坦","土库曼斯坦"};
      string c1_a5[] = {"文莱","柬埔寨","新加坡","印尼","老挝","马来西亚","缅甸","菲律宾","泰国","越南"};
      
      FIND_IN_COUNTRY_GROUPS(1,1,rc,country);
      FIND_IN_COUNTRY_GROUPS(1,2,rc,country);
      FIND_IN_COUNTRY_GROUPS(1,3,rc,country);
      FIND_IN_COUNTRY_GROUPS(1,4,rc,country);
      FIND_IN_COUNTRY_GROUPS(1,5,rc,country);
      
      // EUROPE
      string c2_a1[] = {"白俄罗斯","保加利亚","捷克","匈牙利","摩尔多瓦","波兰","罗马尼亚","俄罗斯","斯洛伐克","乌克兰"};
      string c2_a2[] = {"阿尔巴尼亚","安道尔","克罗地亚","直布罗陀","希腊","意大利","马其顿","马耳他","萄葡牙","圣马力诺","塞尔维亚","斯洛文尼亚","西班牙","梵蒂冈"};
      string c2_a3[] = {"奧地利","比利时","法国","德国","列士敦士登","卢森堡","摩纳哥","荷兰","瑞士"};
      string c2_a4[] = {"丹麦","爱沙尼亚","芬兰","冰岛","爱尔兰","拉脱维亚","立陶宛","挪威","瑞典","英国"};

      FIND_IN_COUNTRY_GROUPS(2,1,rc,country);
      FIND_IN_COUNTRY_GROUPS(2,2,rc,country);
      FIND_IN_COUNTRY_GROUPS(2,3,rc,country);
      FIND_IN_COUNTRY_GROUPS(2,4,rc,country);
      
      //  NORTH AMERICA
      string c3_a0[] = {"美国","加拿大","墨西哥","安提瓜和巴布达","巴哈马","巴巴多斯","伯利兹","哥斯达黎加","古巴","多米尼克","多米尼加","萨尔瓦多","格林纳达","危地马拉","海地","洪都拉斯","牙买加","尼加拉瓜","巴拿马","圣基茨和尼维斯","圣卢西亚","圣文森特和格林纳丁斯","特立尼达和多巴哥"};
      FIND_IN_COUNTRY_GROUPS(3,0,rc,country);

      //  SOUTH AMERICA
      string c4_a0[] = {"智利","秘鲁","委内瑞拉","巴西","哥伦比亚","厄瓜多尔","乌拉圭","巴拉圭","阿根廷","玻利维亚","圭亚那","苏里南","法属圭亚那"};
     FIND_IN_COUNTRY_GROUPS(4,0,rc,country);

      //  OCEANIA
      string c5_a0[] = {"澳大利亚","新西兰","密克罗尼西亚联邦","马绍尔群岛","基里巴斯","瑙鲁","巴布亚新几内亚","所罗门群岛","瓦努阿图","图瓦卢","萨摩亚","汤加","纽埃","库克群岛"};
     FIND_IN_COUNTRY_GROUPS(5,0,rc,country);

      //  AFRICA
      string c6_a1[] = {"布隆迪","科摩罗","吉布提","厄立特里亚","埃塞俄比亚","肯尼亚","马达加斯加","马拉维","毛里求斯","马约特","莫桑比克","卢旺达","塞舌尔","索马里","坦桑尼亚","乌干达","赞比亚","津巴布韦"};
      string c6_a2[] = {"博茨瓦纳","莱索托","纳米比亚","南非","斯威士兰"};
      string c6_a3[] = {"贝宁","布基纳法索","佛得角","科特迪瓦","冈比亚","加纳","几内亚","几内亚比绍","利比里亚","马里","毛里塔尼亚","尼日尔","尼日利亚","塞内加尔","塞拉利昂","多哥"};
      string c6_a4[] = {"阿尔及利亚","埃及","利比亚","摩洛哥","苏丹","突尼斯","西撒哈拉"};
      string c6_a5[] = {"安哥拉","喀麦隆","乍得","刚果共和国","刚果民主共和国","赤道几内亚","加蓬","圣多美和普林西比"};

      FIND_IN_COUNTRY_GROUPS(6,1,rc,country);
      FIND_IN_COUNTRY_GROUPS(6,2,rc,country);
      FIND_IN_COUNTRY_GROUPS(6,3,rc,country);
      FIND_IN_COUNTRY_GROUPS(6,4,rc,country);
      FIND_IN_COUNTRY_GROUPS(6,5,rc,country);
      
      // printf("%d\n", sizeof(a)/sizeof(void *));
      // printf("%d\n", sizeof(a));
      return &rc;
  }

  bbip_province_zone_t *_getProvinceData(string country, string province, string isp) {
      static bbip_province_zone_t rc = { 0, 0, 0 };
      
      rc.province = 0;
      rc.province_area = 0;
      rc.isp = 0;

      if (country == "加拿大") {       
        string c0_a1[] = {"马尼托巴省","新不伦瑞克省","纽芬兰与拉布拉多省","新斯科舍省","安大略省","爱德华王子省","魁北克省"};
        string c0_a3[] = {"艾伯塔省","不列颠哥伦比亚省","萨斯喀彻温省"};
        string c0_a4[] = {"西北地区","努纳武特地区","育空地区"};
        
        FIND_IN_PROVINCE_GROUPS(1,rc,province);
        FIND_IN_PROVINCE_GROUPS(3,rc,province);
        FIND_IN_PROVINCE_GROUPS(4,rc,province);
        
        if (rc.province_area == 0) {
          rc.province = 255;
          rc.province_area = 15;
          rc.isp = 0; 
        }
        return &rc;
      } else if (country == "中国") {
        rc.province = 255;
        rc.province_area = 15;

        string c0_a5[] = {"北京","天津","河北","内蒙古","山西","山东"};
        string c0_a6[] = {"上海","浙江","江苏","安徽"};
        string c0_a7[] = {"广东","福建","广西","海南"};
        string c0_a8[] = {"河南","湖北","湖南","江西"};
        string c0_a9[] = {"四川","重庆","云南","贵州"};
        string c0_a10[] = {"辽宁","吉林","黑龙江"};
        string c0_a11[] = {"陕西","宁夏","青海","甘肃","新疆"};
        string c0_a12[] = {"香港","澳门","台湾"};

        FIND_IN_PROVINCE_GROUPS(5,rc,province);
        FIND_IN_PROVINCE_GROUPS(6,rc,province);
        FIND_IN_PROVINCE_GROUPS(7,rc,province);
        FIND_IN_PROVINCE_GROUPS(8,rc,province);
        FIND_IN_PROVINCE_GROUPS(9,rc,province);
        FIND_IN_PROVINCE_GROUPS(10,rc,province);
        FIND_IN_PROVINCE_GROUPS(11,rc,province);
        FIND_IN_PROVINCE_GROUPS(12,rc,province);
        
        if (isp == "电信") {
            rc.isp = 1;
        } else if (isp == "联通") {
            rc.isp = 2;
        } else if (isp == "移通" || isp == "移动" || isp == "铁通") {
            rc.isp = 3;
        } else if (isp == "教育网") {
            rc.isp = 4;
        } else if (isp == "长城宽带" || isp == "电信通") {
            rc.isp = 9;
        } else if (isp == "PCCW") {
            rc.isp = 10;
        } else if (isp == "HKBN") {
            rc.isp = 11;
        } else {
            rc.isp = 63;
        }
        return &rc;
      } else {
        return &rc;
      }
  }

  int64_t GetZoneID(const std::string& string_ip) {
    struct in_addr addr;
    unsigned long ip;
    if (!inet_aton(string_ip.c_str(), &addr))
    {
        InvalidOperation io;
        io.code = 1;
        io.msg = "Argument 1 must be a IP. Failed to resolve IP.";
        throw io;
    }
    ip = ntohl(addr.s_addr);

    long key = bbip_query(this->ps,ip);
    if (key == 0) {
        return 0;
    } else {
        if (ps->index_ptr[key] == 0)
        {
            this->ps->ptr = BASE_PTR+(this->ps->nCount*2+key-1)*sizeof(int);
            this->ps->index_ptr[key] = htonl(*(int *)(this->ps->mmap+this->ps->ptr));
        }
        this->ps->ptr = this->ps->index_ptr[key]+4;

        unsigned char ilen;
        char *data;

        data=bbip_getstr(ps,&ilen);
        std::string country(data,ilen);

        data=bbip_getstr(ps,&ilen);
        std::string province(data,ilen);

        data=bbip_getstr(ps,&ilen);
        data=bbip_getstr(ps,&ilen);

        data=bbip_getstr(ps,&ilen);
        std::string isp(data, ilen);


        bbip_country_zone_t _country = *this->_getCountryData(country);
        bbip_province_zone_t _prov = *this->_getProvinceData(country, province, isp);
        // printf("contient: %d, area: %d, country: %d\n", _country.contient, _country.area, _country.country);
        // printf("prov: %d, area: %d, isp: %d\n", _prov.province, _prov.province_area, _prov.isp);
        return _prov.isp | (_prov.province << 6) | (_prov.province_area << (6+8)) | 
           (_country.country << (6+8+4)) | (_country.area << (6+8+4+6)) | (_country.contient << (6+8+4+6+3));
    }
    return 0;
  }

  void query_long(bbip_result& _return, const int64_t int_ip) {
    // Your implementation goes here
    long key = bbip_query(this->ps,int_ip);
    if (key == 0) {
        InvalidOperation io;
        io.code = 2;
        io.msg = "Resolve IP failed, ip library have no data for this IP.";
        throw io;
    } else {
        if (ps->index_ptr[key] == 0)
        {
            this->ps->ptr = BASE_PTR+(this->ps->nCount*2+key-1)*sizeof(int);
            this->ps->index_ptr[key] = htonl(*(int *)(this->ps->mmap+this->ps->ptr));
        }
        this->ps->ptr = this->ps->index_ptr[key]+4;

        int bit = rangeToCidrSize(int_ip, this->ps->index_start[key],this->ps->index_end[key]); 
      
        unsigned char ilen;
        char *data;

        _return.range_start = ps->index_start[key];
        _return.range_end = ps->index_end[key];

        data=bbip_getstr(ps,&ilen);
        _return.country.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        _return.province.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        _return.city.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        _return.district.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        _return.isp.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        _return.type.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        _return.desc.assign(data, ilen);

        data=bbip_getstr(ps,&ilen);
        if (ilen > 0) {
            double d = atof_length(data, ilen);
            _return.lat = d;
            _return.__isset.lat = true;
        } else {
            _return.__isset.lat = false;
        }

        data=bbip_getstr(ps,&ilen);
        if (ilen > 0) {
            double d = atof_length(data, ilen);
            _return.lng = d;
            _return.__isset.lng = true;
        } else {
            _return.__isset.lng = false;          
        }

        _return.cidr = bit;
    }
  }
  
  void query_string(std::string& _return, const std::string& string_ip) {
    struct in_addr addr;
    unsigned long int_ip;
    if (!inet_aton(string_ip.c_str(), &addr))
    {
        InvalidOperation io;
        io.code = 1;
        io.msg = "Argument 1 must be a IP. Failed to resolve IP.";
        throw io;
    }
    int_ip = ntohl(addr.s_addr);
    // Your implementation goes here
    long key = bbip_query(this->ps,int_ip);
    if (key == 0) {
        InvalidOperation io;
        io.code = 2;
        io.msg = "Resolve IP failed, ip library have no data for this IP.";
        throw io;
    } else {
        if (ps->index_ptr[key] == 0)
        {
            this->ps->ptr = BASE_PTR+(this->ps->nCount*2+key-1)*sizeof(int);
            this->ps->index_ptr[key] = htonl(*(int *)(this->ps->mmap+this->ps->ptr));
        }
        this->ps->ptr = this->ps->index_ptr[key]+4;

        unsigned char ilen;
        char *data;

        _return = "";

        data=bbip_getstr(ps,&ilen);
        if (ilen) {
            _return += string(data, ilen);
        }

        data=bbip_getstr(ps,&ilen);
        if (ilen) {
            _return += (_return.length() > 0 ? " " : "")+string(data, ilen);
        }
        
        data=bbip_getstr(ps,&ilen);
        if (ilen) {
            _return += (_return.length() > 0 ? " " : "")+string(data, ilen);
        }
        
        data=bbip_getstr(ps,&ilen);

        data=bbip_getstr(ps,&ilen);
        if (ilen) {
            _return += (_return.length() > 0 ? " " : "")+string(data, ilen);
        }
    }
  }
  
  int construct(FILE *fp) {
      int bbip_eo = 0;
      bbip_t *rc;
      this->ps = new bbip_t;

      rc = bbip_init(ps, fp, &bbip_eo);
      if (rc == NULL) {
        switch (errno) {
          case 1:
            fprintf(stderr, "Can't load bbip library\n");
            return 0;
          case 2:
            fprintf(stderr, "Can't load bbip library, read error\n");
            return 0;
          case 3:
            fprintf(stderr, "Can't load bbip library\n");
            return 0;
          default:
            fprintf(stderr, "Unknow bpbp library error: %d\n", errno);
            return 0;
        }
      } else {
          return 1;
      }
  }
  
  
  int preload() {
    if (bbip_preload(this->ps) != 0) {
        fprintf(stderr, "Can't load bbip library\n");
        return 0;
    }
    return 1;
  }

 private:
  bbip_t *ps;

};
int main(int argc, char **argv) {
    struct rlimit rt;

    int port = 12233;
    int max_connections = 65536;
    char bbip_file[256];
    int cmd_opt = 0;
    strcpy(bbip_file, "BBIP.dat");

    static struct option long_options[] = {  
      { "help", 0, 0, 'h' },
      { "port", 1, 0, 'p' },
      { "datafile", 1, 0, 'd' },
      { "max_connections", 1, 0, 'c' },
      { 0, 0, 0, 0 }
    };

    while(1) {
        cmd_opt = getopt_long(argc, argv, "d:p:c:", long_options, NULL);

        /* End condition always first */
        if (cmd_opt == -1) {
            break;
        }

        /* Lets parse */
        switch (cmd_opt) {          
            case 'd':
                strcpy(bbip_file, optarg);
                // fprintf(stderr, "option arg:%s\n", optarg);
                break;

          /* Optional args */
          case 'p':
              if (optarg) {
                  port = atoi(optarg);
              }
              break;

          case 'c':
              if (optarg) {
                  max_connections = atoi(optarg);
              }
              break;

        /* Error handle: Mainly missing arg or illegal option */
        case '?':
            fprintf(stderr, "Illegal option:-%c\n", isprint(optopt)?optopt:'#');
            return 1;
            break;
        default:
            fprintf(stderr, "Not supported option\n");
            break;
        }
    }

    rt.rlim_max = rt.rlim_cur = 1024;
    
    if (setrlimit(RLIMIT_CORE, &rt) == -1) {
      perror(  "setrlimit(RLIMIT_CORE) failed");
    }
    
    rt.rlim_max = rt.rlim_cur = 2097152;  /** max 2G **/
    
    if (setrlimit(RLIMIT_RSS, &rt) == -1) {
      perror(  "setrlimit(RLIMIT_RSS) failed");
    }
    /** Initalize config **/
    
    /* set max limit */
    rt.rlim_max = rt.rlim_cur = max_connections + 10;
    if (setrlimit(RLIMIT_NOFILE, &rt) == -1) {
      perror("setrlimit");
      //exit(1);
    }

    FILE *fp = fopen(bbip_file, "rb");
    if (fp == NULL) {
        fprintf(stderr, "Can't load bbip library\n");
        return 1;
    }

    shared_ptr<bbipHandler> handler(new bbipHandler());
    if (handler->construct(fp) == 0) {
        return 1;
    }
    if (!handler->preload()) {
        return 1;
    }
    // bbip_country_zone_t *rc = handler->_getCountryData("加拿大");
    // printf("contient: %d, area: %d, country: %d\n", rc->contient, rc->area, rc->country);

    // bbip_province_zone_t *rd = handler->_getProvinceData("中国", "河北", "");
    // printf("prov: %d, area: %d, isp: %d\n", rd->province, rd->province_area, rd->isp);

    shared_ptr<TProcessor> processor(new bbipProcessor(handler));
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    // shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(50);
    // shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory > (new PosixThreadFactory());
    // threadManager->threadFactory(threadFactory);  
    // threadManager->start();  

    // TNonblockingServer server(processor, protocolFactory, port, threadManager);
    // server.serve();

    // shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TTransportFactory> transportFactory(new TFramedTransportFactory());
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));

    TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();

    return 0;
}

